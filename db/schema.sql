-- Golf Tour (Supabase) initial schema (MVP A: public shows nickname + status only)
-- Run this in Supabase Dashboard → SQL Editor (one-time init).
-- Public disclosure scope (A): registrations table contains ONLY public fields.
-- Private fields (phone, etc.) can be added later in a separate admin-only table.

-- Extensions
create extension if not exists "pgcrypto";

-- =========
-- 1) Profiles (one row per auth user)
-- =========
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  nickname text not null,
  full_name text,
  is_admin boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row
execute function public.set_updated_at();

-- Create a profile automatically when a user signs up
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, nickname, full_name)
  values (new.id, coalesce(new.raw_user_meta_data->>'nickname', '익명'), new.raw_user_meta_data->>'full_name')
  on conflict (id) do nothing;
  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();

-- =========
-- 2) Tournaments (public readable)
-- =========
create table if not exists public.tournaments (
  id bigint generated by default as identity primary key,
  title text not null,
  course_name text,
  location text,
  event_date date not null,
  tee_time text,
  notes text,
  open_at timestamptz,
  close_at timestamptz,
  status text not null default 'draft' check (status in ('draft','open','closed','done')),
  created_by uuid references auth.users(id),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists trg_tournaments_updated_at on public.tournaments;
create trigger trg_tournaments_updated_at
before update on public.tournaments
for each row
execute function public.set_updated_at();

-- =========
-- 3) Registrations (public readable, no sensitive fields)
-- =========
create table if not exists public.registrations (
  id bigint generated by default as identity primary key,
  tournament_id bigint not null references public.tournaments(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  nickname text not null,
  status text not null default 'applied'
    check (status in ('applied','confirmed','waitlisted','canceled')),
  memo text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (tournament_id, user_id)
);

drop trigger if exists trg_registrations_updated_at on public.registrations;
create trigger trg_registrations_updated_at
before update on public.registrations
for each row
execute function public.set_updated_at();

-- =========
-- 4) Tournament files (admin managed)
-- =========
create table if not exists public.tournament_files (
  id bigint generated by default as identity primary key,
  tournament_id bigint not null references public.tournaments(id) on delete cascade,
  file_type text not null default 'other' check (file_type in ('groups','notice','other')),
  file_name text not null,
  storage_path text not null, -- e.g. bucket path
  is_public boolean not null default true,
  uploaded_by uuid references auth.users(id),
  created_at timestamptz not null default now()
);

-- =========
-- 5) Audit logs (keep history)
-- =========
create table if not exists public.audit_logs (
  id bigint generated by default as identity primary key,
  entity_type text not null,     -- e.g. 'registration'
  entity_id bigint not null,     -- registrations.id etc.
  action text not null,          -- 'insert'/'update'/'delete'
  actor_id uuid,                 -- auth.uid() at time of change (can be null)
  before jsonb,
  after jsonb,
  created_at timestamptz not null default now()
);

-- Trigger to log registration changes
create or replace function public.log_registration_changes()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  if (tg_op = 'INSERT') then
    insert into public.audit_logs(entity_type, entity_id, action, actor_id, before, after)
    values ('registration', new.id, 'insert', auth.uid(), null, to_jsonb(new));
    return new;
  elsif (tg_op = 'UPDATE') then
    insert into public.audit_logs(entity_type, entity_id, action, actor_id, before, after)
    values ('registration', new.id, 'update', auth.uid(), to_jsonb(old), to_jsonb(new));
    return new;
  elsif (tg_op = 'DELETE') then
    insert into public.audit_logs(entity_type, entity_id, action, actor_id, before, after)
    values ('registration', old.id, 'delete', auth.uid(), to_jsonb(old), null);
    return old;
  end if;

  return null;
end;
$$;

drop trigger if exists trg_log_registration_changes on public.registrations;
create trigger trg_log_registration_changes
after insert or update or delete on public.registrations
for each row
execute function public.log_registration_changes();

-- =========
-- RLS + Policies
-- =========
alter table public.profiles enable row level security;
alter table public.tournaments enable row level security;
alter table public.registrations enable row level security;
alter table public.tournament_files enable row level security;
alter table public.audit_logs enable row level security;

-- Helper: is_admin()
create or replace function public.is_admin(uid uuid)
returns boolean
language sql
stable
as $$
  select exists (
    select 1 from public.profiles p
    where p.id = uid and p.is_admin = true
  );
$$;

-- ---- Profiles policies
-- Users can read/update their own profile; admins can read all
drop policy if exists "profiles_select_own_or_admin" on public.profiles;
create policy "profiles_select_own_or_admin"
on public.profiles for select
using (auth.uid() = id or public.is_admin(auth.uid()));

drop policy if exists "profiles_update_own" on public.profiles;
create policy "profiles_update_own"
on public.profiles for update
using (auth.uid() = id)
with check (auth.uid() = id);

-- ---- Tournaments policies
-- Anyone can read tournaments (public list)
drop policy if exists "tournaments_select_public" on public.tournaments;
create policy "tournaments_select_public"
on public.tournaments for select
using (true);

-- Admins can insert/update/delete tournaments
drop policy if exists "tournaments_write_admin" on public.tournaments;
create policy "tournaments_write_admin"
on public.tournaments for all
using (public.is_admin(auth.uid()))
with check (public.is_admin(auth.uid()));

-- ---- Registrations policies
-- Anyone can read registrations (public status view) - safe because table has no sensitive fields
drop policy if exists "registrations_select_public" on public.registrations;
create policy "registrations_select_public"
on public.registrations for select
using (true);

-- Authenticated users can insert their own registration
drop policy if exists "registrations_insert_own" on public.registrations;
create policy "registrations_insert_own"
on public.registrations for insert
with check (
  auth.uid() = user_id
);

-- Users can update/cancel their own registration
drop policy if exists "registrations_update_own" on public.registrations;
create policy "registrations_update_own"
on public.registrations for update
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

-- Admin can update anyone (for confirm/waitlist etc.)
drop policy if exists "registrations_admin_update" on public.registrations;
create policy "registrations_admin_update"
on public.registrations for update
using (public.is_admin(auth.uid()))
with check (public.is_admin(auth.uid()));

-- ---- Tournament files policies
-- Anyone can read public files (is_public = true)
drop policy if exists "tournament_files_select_public" on public.tournament_files;
create policy "tournament_files_select_public"
on public.tournament_files for select
using (is_public = true);

-- Admin can manage files
drop policy if exists "tournament_files_write_admin" on public.tournament_files;
create policy "tournament_files_write_admin"
on public.tournament_files for all
using (public.is_admin(auth.uid()))
with check (public.is_admin(auth.uid()));

-- ---- Audit logs policies
-- Admin only
drop policy if exists "audit_logs_admin_only" on public.audit_logs;
create policy "audit_logs_admin_only"
on public.audit_logs for select
using (public.is_admin(auth.uid()));

-- =========
-- Optional seed (safe to remove)
-- =========
insert into public.tournaments (title, course_name, location, event_date, status)
values ('테스트 대회', '클럽 흑 금강', '충북', '2026-02-28', 'open')
on conflict do nothing;
